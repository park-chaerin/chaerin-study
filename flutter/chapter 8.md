## 08-1 화면을 구성하는 위젯
#### 위젯
- 화면에 보인 뷰를 설명하는 객체.
- 플러터에서는 화면과 관련된 모든 것이 위젯.
- Widget과 Text, Center클래스의 계층
  - Object --> DiagonosticableTree --> Widget
  - Object --> DiagonosticableTree --> Widget --> StatelessWidget --> Text
  - Object --> DiagonosticableTree --> Widget --> RenderObjectWidget --> SingleChildRenderObjectWidget --> Align --> Center

### 선언형 프로그래밍으로 화면 구성
- 플러터는 선언형 프로그래밍으로 화면 구성 (<--> 명령형 프로그래밍)
- 선언형 프로그래밍 : 프론트엔드 프레임워크가 제공하는 기법. 리액트 프레임워크에서 영감을 얻어 설계.

### 위젯 : 불변객체
- 위젯은 객체를 생성한 후 상태를 바꿀 수 없음.
- 만약 화면을 새 데이터로 갱신하려면 새로운 위젯 객체를 생성해야 함. 
#### 그렇다면 위젯 객체를 다시 생성한다는 게 비효율적이지 않을까?
  - 위젯은 위젯일 뿐 실제화면이 아님!
  - 화면에 출력할 정보를 가지는 객체일뿐

## 08-2 위젯 트리 알아보기
### 위젯의 트리 구조
- 한 화면을 구성하는 모든 위젯은 단일 트리 구조를 이룸.

### 화면을 구성하는 3개 트리 구조
- 위젯 트리
- 엘리먼트 트리  -> 프레임워크를 이해하는 차원으로 알아두면 좋음.
- 렌더 트리     -> 프레임워크를 이해하는 차원으로 알아두면 좋음.
- 실제 앱을 개발할 때는 이보다 많은 위젯으로 복잡하게 화면을 구성하기 때문에 코드만 보고 전체 위젯의 트리를 파악하기 어려움.
  - 이때! 안드로이드 스튜디오의 플러터 인스펙터 도구를 이용하면 됨.
- 플러터 프레임워크는 위젯 트리를 기반으로 엘리먼트 트리를 생성함. (위젯 하나당 엘리먼트 객체를 하나씩 만들어 트리 구성, 위젯보다 더 상세한 정보가 담김)
#### 엘리먼트 트리
- 엘리먼트 트리는 ComponentElement / RenderObjectElement 객체로 구성됨.
- ComponentElement 객체 : 트리 구조에서 다른 객체를 초함하는 역할만 하며, 화면에 출력할 정보를 가지지는 않음.
- RenderObjectElement 객체 : 실제 화면에 출력할 정보가 담김.
- 엘리먼트 트리의 객체도 실제 화면에 무언가를 출력하지는 않음. 그저 정보만 담고 있을뿐.
  
#### 렌더 트리
- 렌더 트리는 엘리먼트 트리의 정보를 바탕으로 실제 화면을 출력하는 렌더 트리가 만들어짐.
- 렌더 트리의 객체는 위젯 트리와 직접 연계되지 않고, 엘리먼트 객체를 대상으로 렌더 트리가 하나씩 만들어지지도 않음.
- 실제 화면에 출력할 정보를 가지는 RenderObjectElement에 해당하는 객체들로만 구성됨.
- 렌더 트리를 구성하는 객체는 실제 화면을 출력하는 객체.

<img src="https://github.com/park-chaerin/park-chaerin/assets/70634789/7b1f9cae-d638-46c2-891a-91c3fa299ead" width=1000>

#### 왜 이렇게 복잡한 트리 구조를 가질까?
- 위젯 트리, 엘리먼트 트리, 렌더 트리 등이 존재하는 이유 : 렌더링(출력) 속도 때문!

## 08-5 상태의 생명 주기
- StatelessWidget과 StatefulWidget은 화면이 다시 빌드될 때마다 매번 생성되므로 생명주기를 논할 필요 X.
- State는 한 번 생성된 후 메모리에 유지되기때문에 생명 주기를 가짐. -> 생명주기 함수를 재정의 할 수 있음.

<img src= "https://github.com/park-chaerin/chaerin-study/assets/70634789/b1433a29-5ede-4f93-98ab-39b04f57932b" width= 500>

- setState()는 State의 상태를 변경할 때 호출하는 함수. 
- 마름모로 표현한 Dirty와 Clean은 상태.(생명주기 함수가 아님.)
  - clean : State에 의해 화면이 출력되고 있는 정상 상태.
  - dirty : State화면을 다시 빌드해야 하는 상태.

### State클래스에서 재정의할 수 있는 생명 주기 함수
 - initState()
 - didChangeDependencies()
 - build()
 - didUpdateWidget()
 - dispose()

### initState() 함수 호출 시점
- State 객체가 생성되자마자 가장 먼저 최초에 한 번 호출됨.
- 주로 상태값을 초기화하는 로직 작성.
  - ex) State가 생성되자마자 최초에 한 번 서버와 연동해 초기 데이터를 가져와 상태값에 할당하는 코드를 initState()에 작성.
- 다양한 이벤트 처리도 initState() 함수에 작성.
  - 이벤트를 처리하는 리스너는 한 번만 등록하고, 그 이후에 콜백함수만 반복해서 호출하면 되기 때문에 주로 initState()함수에 등록.
    - ex) 앱이 화면에 출력되는 순간이나 화면에서 사라지는 순간 이벤트 처리르 해야할 때 리스너를 initState()함수에 등록.

### didChangeDependencies() 함수 호출 시점
- 